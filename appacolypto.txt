// Single-video pose viewer (p5.js)
// - Uses one video (mainVideo)
// - Mayan-style emoji for heads (ðŸ—¿)
// - Keeps pose controls, looping toggle, drag/scale, emoji scale slider, volume, etc.

let poseData = [];
let poseMap = {};
let mainVideo;
let poseTime = 0;
let showPose = true;
let scaleCycle = [1.0, 0.75, 0.5, 0.25];
let scaleIndex = 0;
let scaleFactor = scaleCycle[scaleIndex];
let offsetX = 0, offsetY = 0;
let isDragging = false, dragStartX, dragStartY;
const fps = 30;
let posePlaying = false;
let posePlaybackRate = 1;
let sliderMain, speedInput;
let volumeSlider;
const skeletonEdges = [
  [5, 7], [7, 9], [6, 8], [8, 10],
  [11, 13], [13, 15], [12, 14], [14, 16],
  [5, 6], [11, 12], [5, 11], [6, 12]
];

// Use a single static "Mayan" emoji for every head
const headEmojis = ["ðŸ—¿"];
const crownEmoji = "ðŸª¶";
let loopPoseUntilVideoEnds = false;

// store previous frame head positions (for optional velocity)
let lastHeads = [];

// emoji global scale (1..20)
let emojiGlobalScale = 5;
let emojiScaleSlider, emojiScaleLabel;

function preload() {
  poseData = loadJSON('apacalyptoaianalyisis.json');
  mainVideo = createVideo(['minikii.mp4']);
}

function setup() {
  // Single video canvas; keep aspect similar to earlier (960x720)
  createCanvas(960, 720);
  frameRate(fps);

  mainVideo.hide();

  // Default: allow sound and set a reasonable volume
  mainVideo.volume(1);
  mainVideo.elt.muted = false;
  mainVideo.loop();

  // Load pose data into map (supports array or object)
  (Array.isArray(poseData) ? poseData : Object.values(poseData)).forEach(entry => {
    if (!poseMap[entry.frame_id]) poseMap[entry.frame_id] = [];
    poseMap[entry.frame_id].push(entry.keypoints);
  });

  const yBase = height - 80;

  // === MAIN VIDEO CONTROLS ===
  createButton('Play').position(10, yBase).mousePressed(() => mainVideo.play());
  createButton('Pause').position(80, yBase).mousePressed(() => mainVideo.pause());
  createButton('Stop').position(150, yBase).mousePressed(() => { mainVideo.pause(); mainVideo.time(0); });
  createButton('<< -10s').position(220, yBase).mousePressed(() => mainVideo.time(max(0, mainVideo.time() - 10)));
  createButton('+10s').position(300, yBase).mousePressed(() => mainVideo.time(min(mainVideo.duration(), mainVideo.time() + 10)));

  // Load video duration and create main slider when metadata ready
  mainVideo.elt.onloadedmetadata = () => {
    sliderMain = createSlider(0, mainVideo.duration(), 0, 0.01)
      .position(10, yBase + 30).style('width', '620px')
      .input(() => mainVideo.time(sliderMain.value()));
  };

  // === POSE CONTROLS ===
  const poseY = yBase - 10;
  createButton('Play Pose').position(650, poseY).mousePressed(() => { posePlaying = true; mainVideo.pause(); });
  createButton('Pause Pose').position(730, poseY).mousePressed(() => posePlaying = false);
  createButton('Stop Pose').position(810, poseY).mousePressed(() => { posePlaying = false; poseTime = 0; mainVideo.pause(); });
  createButton('<< -10s Pose').position(890, poseY).mousePressed(() => { poseTime = max(poseTime - 10, 0); mainVideo.pause(); });

  // Loop toggle
  const loopToggle = createButton('Loop Pose Until Video Ends: OFF')
    .position(360, poseY)
    .mousePressed(() => {
      loopPoseUntilVideoEnds = !loopPoseUntilVideoEnds;
      loopToggle.html(`Loop Pose Until Video Ends: ${loopPoseUntilVideoEnds ? 'ON' : 'OFF'}`);
    });

  createSpan('Speed:').position(650, yBase);
  speedInput = createInput('1.0').position(700, yBase).size(40);
  speedInput.input(() => {
    const val = parseFloat(speedInput.value());
    posePlaybackRate = isNaN(val) ? 1 : val;
  });

  // emoji scale slider (1..20)
  createSpan('Emoji Scale:').position(760, yBase);
  emojiScaleSlider = createSlider(1, 20, emojiGlobalScale, 1)
    .position(840, yBase).style('width', '100px')
    .input(() => {
      emojiGlobalScale = emojiScaleSlider.value();
      if (emojiScaleLabel) emojiScaleLabel.html(` ${emojiGlobalScale}`);
    });
  emojiScaleLabel = createSpan(` ${emojiGlobalScale}`).position(950, yBase);

  // volume slider for main video
  createSpan('ðŸ”Š Vol:').position(430, yBase);
  volumeSlider = createSlider(0, 1, 1, 0.01).position(480, yBase).style('width', '120px');
}

function draw() {
  background(0);

  // draw the single main video filling the left+center space (0..960, 0..640)
  if (mainVideo.elt.readyState >= 2) {
    image(mainVideo, 0, 0, 960, 640);
    if (sliderMain) sliderMain.value(mainVideo.time());
    if (volumeSlider) mainVideo.volume(volumeSlider.value());
  } else {
    // placeholder if metadata not loaded yet
    fill(30);
    noStroke();
    rect(0, 0, 960, 640);
    fill(200);
    textAlign(CENTER, CENTER);
    text('Loading video...', 480, 320);
  }

  // --- POSE TIMING & looping logic ---
  const dur = (mainVideo && typeof mainVideo.duration === 'function') ? mainVideo.duration() : 0;

  if (posePlaying) {
    poseTime += (deltaTime / 1000) * posePlaybackRate;

    if (dur > 0) {
      if (loopPoseUntilVideoEnds) {
        // If video element is set to loop, behave modularly; otherwise ensure we stop at end
        if (!mainVideo.elt.loop) {
          if (mainVideo.elt.readyState >= 2 && mainVideo.time() >= dur - 0.05) {
            poseTime = dur;
            posePlaying = false;
          } else {
            poseTime = poseTime % dur;
            if (poseTime < 0) poseTime += dur;
          }
        } else {
          poseTime = poseTime % dur;
          if (poseTime < 0) poseTime += dur;
        }
      } else {
        poseTime = poseTime % dur;
        if (poseTime < 0) poseTime += dur;
      }
    }
  } else if (!mainVideo.elt.paused) {
    // sync pose to video when video is playing and pose not playing
    poseTime = mainVideo.time();
  }

  // when mainVideo is paused, keep video time at poseTime (so frame matches)
  if (mainVideo.elt.paused) {
    if (dur > 0) mainVideo.time(constrain(poseTime, 0, max(0.0001, dur)));
    else mainVideo.time(poseTime);
  }

  if (showPose) drawPoseOverlay();
}

/*
 drawPoseOverlay â€” computes screen coordinates for keypoints and:
 - draws skeleton & dots (with shear applied)
 - draws emoji at head positions (NOT sheared), sized by shoulderDist or emojiGlobalScale
 - crown logic: finds person closest to video center (x=480) and draws crown
*/
function drawPoseOverlay() {
  const frameIndex = floor(poseTime * fps);
  const persons = poseMap[frameIndex] || [];

  // video natural dims (fallback to 960x640)
  const vidW = (mainVideo.elt.videoWidth && mainVideo.elt.videoWidth > 0) ? mainVideo.elt.videoWidth : 960;
  const vidH = (mainVideo.elt.videoHeight && mainVideo.elt.videoHeight > 0) ? mainVideo.elt.videoHeight : 640;
  // scale to displayed size (we draw at 960x640)
  const scaleX = 960 / vidW;
  const scaleY = 640 / vidH;

  // shear factor (lean left slightly; same approach as earlier)
  const shearAngle = -0.12;
  const shearFactor = Math.tan(shearAngle);

  let personsScreen = [];

  persons.forEach((kpts, pIndex) => {
    const kptsScreen = kpts.map(pt => {
      if (!pt) return null;
      let x = pt[0], y = pt[1];
      let tx = x * scaleX;
      let ty = y * scaleY;
      tx *= scaleFactor;
      ty *= scaleFactor;
      tx = tx + shearFactor * ty; // shearX
      const screenX = offsetX + tx;
      const screenY = offsetY + ty;
      return { x: screenX, y: screenY, rawX: x, rawY: y };
    });

    // head: prefer nose (index 0), else average eyes (1,2)
    let headScreen = null;
    if (kptsScreen[0]) headScreen = kptsScreen[0];
    else {
      const le = kptsScreen[1], re = kptsScreen[2];
      if (le && re) headScreen = { x: (le.x + re.x) / 2, y: (le.y + re.y) / 2 };
      else if (le) headScreen = le;
      else if (re) headScreen = re;
    }

    // shoulder distance (5 & 6)
    let shoulderDist = null;
    if (kptsScreen[5] && kptsScreen[6]) {
      const dx = (kptsScreen[5].x - kptsScreen[6].x);
      const dy = (kptsScreen[5].y - kptsScreen[6].y);
      shoulderDist = sqrt(dx * dx + dy * dy);
    }

    personsScreen.push({ kptsScreen, headScreen, shoulderDist });
  });

  // draw keypoint dots
  noStroke();
  fill(255, 0, 0);
  personsScreen.forEach(ps => {
    ps.kptsScreen.forEach(pt => {
      if (pt) circle(pt.x, pt.y, 10);
    });
  });

  // draw skeleton lines
  stroke(255, 255, 0);
  strokeWeight(4 / max(0.001, scaleFactor));
  strokeCap(SQUARE);
  personsScreen.forEach(ps => {
    skeletonEdges.forEach(([i, j]) => {
      const a = ps.kptsScreen[i], b = ps.kptsScreen[j];
      if (a && b) line(a.x, a.y, b.x, b.y);
    });
  });

  // draw emojis at head positions (NOT sheared)
  textAlign(CENTER, CENTER);
  let newLastHeads = [];

  personsScreen.forEach((ps, idx) => {
    if (!ps.headScreen) {
      newLastHeads.push(null);
      return;
    }
    const h = ps.headScreen;

    // velocity calc (retained for future use)
    let vel = 0;
    if (lastHeads[idx]) {
      const dx = h.x - lastHeads[idx].x;
      const dy = h.y - lastHeads[idx].y;
      const dt = max(1 / fps, (deltaTime || (1000 / fps)) / 1000);
      vel = sqrt(dx * dx + dy * dy) / dt;
    }
    newLastHeads.push({ x: h.x, y: h.y });

    const emoji = headEmojis[0];

    // determine size: use shoulderDist if available, else use baseline
    let size = 140 * scaleFactor * (emojiGlobalScale / 10);
    if (ps.shoulderDist) {
      size = constrain(ps.shoulderDist * 3.2, 100, 420) * (emojiGlobalScale / 10);
    } else {
      size = max(size, 140 * (emojiGlobalScale / 10));
    }

    // static emoji (no bob/pulse)
    const drawSize = constrain(max(20, size), 20, 420);

    // shadow + emoji (not sheared)
    fill(0, 200);
    textSize(drawSize);
    text(emoji, h.x + 6, h.y + 6);
    fill(255);
    text(emoji, h.x, h.y);
  });

  lastHeads = newLastHeads;

  // crown logic: who is closest to center of video (x=480)
  const videoCenterX = 480;
  const centerThreshold = 120;
  let best = null, bestDist = Infinity;
  personsScreen.forEach(ps => {
    if (!ps.headScreen) return;
    const sx = ps.headScreen.x;
    if (sx >= 0 && sx <= 960) {
      const d = abs(sx - videoCenterX);
      if (d < bestDist) {
        bestDist = d;
        best = ps;
      }
    }
  });

  if (best && bestDist <= centerThreshold && best.headScreen) {
    const approxScreenSize = best.shoulderDist ? (best.shoulderDist * 3.2 * (emojiGlobalScale / 10)) : (140 * (emojiGlobalScale / 10));
    const crownSize = constrain(approxScreenSize * 0.6, 24, 260);
    const crownX = best.headScreen.x;
    const crownY = best.headScreen.y - ((best.shoulderDist ? best.shoulderDist : 140) * 0.9 * (emojiGlobalScale / 10));

    push();
    textAlign(CENTER, CENTER);
    textSize(crownSize);
    fill(0, 200);
    text(crownEmoji, crownX + 6, crownY + 6);
    fill(255, 215, 0);
    text(crownEmoji, crownX, crownY);
    pop();
  }
}

// ---- interaction handlers ----
function mousePressed() {
  if (showPose) {
    isDragging = true;
    dragStartX = mouseX - offsetX;
    dragStartY = mouseY - offsetY;
  }
}

function mouseDragged() {
  if (isDragging) {
    offsetX = mouseX - dragStartX;
    offsetY = mouseY - dragStartY;
  }
}

function mouseReleased() {
  isDragging = false;
}

function keyPressed() {
  const k = key.toUpperCase();
  if (k === 'T') {
    showPose = !showPose;
  } else if (k === 'B') {
    scaleIndex = (scaleIndex + 1) % scaleCycle.length;
    scaleFactor = scaleCycle[scaleIndex];
    console.log(`Pose Scale: ${scaleFactor}`);
  } else if (k === 'F') {
    poseTime = min(poseTime + 10, mainVideo.duration());
    mainVideo.pause();
  } else if (k === 'R') {
    poseTime = max(poseTime - 10, 0);
    mainVideo.pause();
  }
}
